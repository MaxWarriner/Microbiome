}
# Function to create combined volcano plots
create_combined_volcano <- function(ps, factor, metadata, SVs, taxonomy) {
plots <- list(
create_volcano_plot(ps, 2, factor, metadata, SVs, taxonomy),  # Phylum
create_volcano_plot(ps, 5, factor, metadata, SVs, taxonomy),  # Family
create_volcano_plot(ps, 6, factor, metadata, SVs, taxonomy)   # Genus
)
combined_plot <- (plots[[1]] | plots[[2]]) / plots[[3]]
ggsave(
filename = paste0(factor, "_volcano.pdf"),
plot = combined_plot,
device = "pdf",
width = 12,
height = 8
)
return(combined_plot)
}
for (variable in factors) {
try(create_combined_volcano(ps, variable, metadata, SVs, taxonomy))
}
create_volcano_plot <- function(ps_obj, taxlevel, condition_col, metadata, SVs, taxonomy) {
# Convert sample data to data frame
sam_data <- as(sample_data(ps_obj), "data.frame")
# Get the top two most frequent values in the condition column
value_counts <- table(sam_data[[condition_col]])
top_values <- names(sort(value_counts, decreasing = TRUE))[1:2]
# Filter samples to include only those with the top two condition values
final_keep_samples <- sam_data[[condition_col]] %in% top_values
ps_filtered <- prune_samples(final_keep_samples, ps_obj)
# Ensure the condition variable is factor with the top values
sample_data(ps_filtered)[[condition_col]] <- factor(
sample_data(ps_filtered)[[condition_col]],
levels = top_values
)
# Get filtered OTU names
otu_names_filtered <- rownames(otu_table(ps_filtered))
# Get the taxonomy column name for the specified level
tax_col <- colnames(taxonomy)[taxlevel]
# Create a clean merged data frame
merged_data <- data.frame(
SV = rownames(SVs),
SVs,
Taxonomy = taxonomy[, tax_col],  # Directly access the taxonomy column
stringsAsFactors = FALSE,
check.names = FALSE
) %>%
filter(SV %in% otu_names_filtered) %>%
filter(!is.na(Taxonomy) & Taxonomy != "none" & Taxonomy != "")
# Check if we have any data left after filtering
if(nrow(merged_data) == 0) {
stop(paste("No taxa remaining after filtering for level:", tax_col))
}
# Summarize by taxonomic level (using base R for reliability)
tax_level_SVs <- aggregate(
merged_data[, -which(names(merged_data) %in% c("SV", "Taxonomy"))],
by = list(Taxonomy = merged_data$Taxonomy),
FUN = sum
)
# Convert to matrix format needed by ALDEx2
rownames(tax_level_SVs) <- tax_level_SVs$Taxonomy
tax_level_SVs <- as.matrix(tax_level_SVs[, -1, drop = FALSE])
# Get conditions matching the samples in our matrix
condition <- sample_data(ps_filtered)[colnames(tax_level_SVs), condition_col]] %>%
create_volcano_plot <- function(ps_obj, taxlevel, condition_col, metadata, SVs, taxonomy) {
# Convert sample data to data frame
sam_data <- as(sample_data(ps_obj), "data.frame")
# Get the top two most frequent values in the condition column
value_counts <- table(sam_data[[condition_col]])
top_values <- names(sort(value_counts, decreasing = TRUE))[1:2]
# Filter samples to include only those with the top two condition values
final_keep_samples <- sam_data[[condition_col]] %in% top_values
ps_filtered <- prune_samples(final_keep_samples, ps_obj)
# Ensure the condition variable is factor with the top values
sample_data(ps_filtered)[[condition_col]] <- factor(
sample_data(ps_filtered)[[condition_col]],
levels = top_values
)
# Get filtered OTU names
otu_names_filtered <- rownames(otu_table(ps_filtered))
# Get the taxonomy column name for the specified level
tax_col <- colnames(taxonomy)[taxlevel]
# Create a clean merged data frame
merged_data <- data.frame(
SV = rownames(SVs),
SVs,
Taxonomy = taxonomy[, tax_col],  # Directly access the taxonomy column
stringsAsFactors = FALSE,
check.names = FALSE
) %>%
filter(SV %in% otu_names_filtered) %>%
filter(!is.na(Taxonomy) & Taxonomy != "none" & Taxonomy != "")
# Check if we have any data left after filtering
if(nrow(merged_data) == 0) {
stop(paste("No taxa remaining after filtering for level:", tax_col))
}
# Summarize by taxonomic level (using base R for reliability)
tax_level_SVs <- aggregate(
merged_data[, -which(names(merged_data) %in% c("SV", "Taxonomy"))],
by = list(Taxonomy = merged_data$Taxonomy),
FUN = sum
)
# Convert to matrix format needed by ALDEx2
rownames(tax_level_SVs) <- tax_level_SVs$Taxonomy
tax_level_SVs <- as.matrix(tax_level_SVs[, -1, drop = FALSE])
# Get conditions matching the samples in our matrix
condition <- sample_data(ps_filtered)[colnames(tax_level_SVs), condition_col] %>%
as.character() %>%
as.factor()
# Verify dimensions match
if(length(condition) != ncol(tax_level_SVs)) {
stop(paste("Mismatch between samples (", ncol(tax_level_SVs),
") and conditions (", length(condition), ")"))
}
# Run ALDEx2 with error handling
tryCatch({
aldex_data <- ALDEx2::aldex(
counts = tax_level_SVs,
conditions = condition,
mc.samples = 128,
test = "t",
effect = TRUE
)
# Create volcano plot
results <- aldex_data %>%
rownames_to_column("Taxonomy") %>%
mutate(
Significant = we.eBH < 0.05,
Label = ifelse(Significant, paste0(Taxonomy, " (", round(we.eBH, 3), ")"), "")
)
ggplot(results, aes(x = diff.btw, y = -log10(we.eBH), color = Significant, label = Label)) +
geom_point(alpha = 0.6) +
geom_text_repel(size = 3, max.overlaps = 20, show.legend = FALSE) +
theme_minimal() +
labs(
title = paste("Factor:", condition_col, "- Level:", tax_col),
subtitle = paste("Comparison:", paste(top_values, collapse = " vs ")),
x = "log2(fold change)",
y = "-log10(adjusted p-value)"
) +
theme(legend.position = "none")
}, error = function(e) {
message(paste("Error in ALDEx2 for", condition_col, "at level", tax_col, ":"))
message(e)
return(NULL)
})
}
create_volcano_plot <- function(ps_obj, taxlevel, condition_col, metadata, SVs, taxonomy) {
# Convert sample data to data frame
sam_data <- as(sample_data(ps_obj), "data.frame")
# Get the top two most frequent values in the condition column
value_counts <- table(sam_data[[condition_col]])
top_values <- names(sort(value_counts, decreasing = TRUE))[1:2]
# Filter samples to include only those with the top two condition values
final_keep_samples <- sam_data[[condition_col]] %in% top_values
ps_filtered <- prune_samples(final_keep_samples, ps_obj)
# Ensure the condition variable is factor with the top values
sample_data(ps_filtered)[[condition_col]] <- factor(
sample_data(ps_filtered)[[condition_col]],
levels = top_values
)
# Get filtered OTU names
otu_names_filtered <- rownames(otu_table(ps_filtered))
# Get the taxonomy column name for the specified level
tax_col <- colnames(taxonomy)[taxlevel]
# Create a clean merged data frame
merged_data <- data.frame(
SV = rownames(SVs),
SVs,
Taxonomy = taxonomy[, tax_col],  # Directly access the taxonomy column
stringsAsFactors = FALSE,
check.names = FALSE
) %>%
filter(SV %in% otu_names_filtered) %>%
filter(!is.na(Taxonomy) & Taxonomy != "none" & Taxonomy != "")
# Check if we have any data left after filtering
if(nrow(merged_data) == 0) {
stop(paste("No taxa remaining after filtering for level:", tax_col))
}
# Summarize by taxonomic level (using base R for reliability)
tax_level_SVs <- aggregate(
merged_data[, -which(names(merged_data) %in% c("SV", "Taxonomy"))],
by = list(Taxonomy = merged_data$Taxonomy),
FUN = sum
)
# Convert to matrix format needed by ALDEx2
rownames(tax_level_SVs) <- tax_level_SVs$Taxonomy
tax_level_SVs <- as.matrix(tax_level_SVs[, -1, drop = FALSE])
# Get conditions matching the samples in our matrix
condition <- sample_data(ps_filtered)[colnames(tax_level_SVs), condition_col] %>%
as.character() %>%
as.factor()
# Verify dimensions match
if(length(condition) != ncol(tax_level_SVs)) {
stop(paste("Mismatch between samples (", ncol(tax_level_SVs),
") and conditions (", length(condition), ")"))
}
# Run ALDEx2 with error handling
tryCatch({
aldex_data <- ALDEx2::aldex(
counts = tax_level_SVs,
conditions = condition,
mc.samples = 128,
test = "t",
effect = TRUE
)
# Create volcano plot
results <- aldex_data %>%
rownames_to_column("Taxonomy") %>%
mutate(
Significant = we.eBH < 0.05,
Label = ifelse(Significant, paste0(Taxonomy, " (", round(we.eBH, 3), ")"), "")
)
ggplot(results, aes(x = diff.btw, y = -log10(we.eBH), color = Significant, label = Label)) +
geom_point(alpha = 0.6) +
geom_text_repel(size = 3, max.overlaps = 20, show.legend = FALSE) +
theme_minimal() +
labs(
title = paste("Factor:", condition_col, "- Level:", tax_col),
subtitle = paste("Comparison:", paste(top_values, collapse = " vs ")),
x = "log2(fold change)",
y = "-log10(adjusted p-value)"
) +
theme(legend.position = "none")
}, error = function(e) {
message(paste("Error in ALDEx2 for", condition_col, "at level", tax_col, ":"))
message(e)
return(NULL)
})
}
create_combined_volcano <- function(ps, factor, metadata, SVs, taxonomy) {
plots <- list()
# Try each taxonomic level with error handling
try({
plots[[1]] <- create_volcano_plot(ps, 2, factor, metadata, SVs, taxonomy)  # Phylum
})
try({
plots[[2]] <- create_volcano_plot(ps, 5, factor, metadata, SVs, taxonomy)  # Family
})
try({
plots[[3]] <- create_volcano_plot(ps, 6, factor, metadata, SVs, taxonomy)  # Genus
})
# Remove any NULL plots from failures
plots <- plots[!sapply(plots, is.null)]
if(length(plots) == 0) {
message(paste("No plots generated for factor:", factor))
return(NULL)
}
# Combine available plots
if(length(plots) >= 2) {
combined_plot <- (plots[[1]] | plots[[2]]) /
if(length(plots) > 2) plots[[3]] else patchwork::plot_spacer()
} else {
combined_plot <- plots[[1]]
}
# Add title
combined_plot <- combined_plot +
plot_annotation(
title = paste("Variable:", factor),
theme = theme(plot.title = element_text(size = 16, face = "bold")))
# Save plot
try({
ggsave(
filename = paste0(factor, "_volcano.pdf"),
plot = combined_plot,
device = "pdf",
width = 12,
height = 8
)
})
return(combined_plot)
}
# Run analysis for each factor with robust error handling
for (variable in factors) {
message(paste("\nProcessing variable:", variable))
tryCatch({
create_combined_volcano(ps, variable, metadata, SVs, taxonomy)
}, error = function(e) {
message(paste("Failed to process variable:", variable))
message(e)
})
}
create_volcano_plot <- function(ps_obj, taxlevel, condition_col, metadata, SVs, taxonomy) {
# Convert sample data to data frame
sam_data <- as(sample_data(ps_obj), "data.frame")
# Get the top two most frequent values in the CURRENT condition column only
value_counts <- table(sam_data[[condition_col]])
top_values <- names(sort(value_counts, decreasing = TRUE))[1:2]
# Create logical vector for filtering - affects only this specific variable
keep_samples <- sam_data[[condition_col]] %in% top_values
# Prune samples but keep ALL metadata intact
ps_filtered <- prune_samples(keep_samples, ps_obj)
# Only modify the specific condition column being analyzed
sample_data(ps_filtered)[[condition_col]] <- factor(
sample_data(ps_filtered)[[condition_col]],
levels = top_values
)
# Get OTU names from filtered phyloseq object
otu_names_filtered <- rownames(otu_table(ps_filtered))
# Get taxonomy column name for specified level
tax_col <- colnames(taxonomy)[taxlevel]
# Create merged data - only filter OTUs, keep all sample info
merged_data <- data.frame(
SV = rownames(SVs),
SVs,
Taxonomy = taxonomy[, tax_col],  # Direct column access
stringsAsFactors = FALSE,
check.names = FALSE
) %>%
filter(SV %in% otu_names_filtered) %>%  # Only filter OTUs here
filter(!is.na(Taxonomy) & Taxonomy != "none" & Taxonomy != "")
# Check if data remains after filtering
if(nrow(merged_data) == 0) {
stop(paste("No taxa remaining after filtering for:", tax_col))
}
# Summarize by taxonomic level (base R for reliability)
tax_level_SVs <- aggregate(
merged_data[, -which(names(merged_data) %in% c("SV", "Taxonomy"))],
by = list(Taxonomy = merged_data$Taxonomy),
FUN = sum
)
# Prepare ALDEx2 input
rownames(tax_level_SVs) <- tax_level_SVs$Taxonomy
tax_level_SVs <- as.matrix(tax_level_SVs[, -1, drop = FALSE])
# Get conditions - ensures perfect matching
condition <- sample_data(ps_filtered)[colnames(tax_level_SVs), condition_col]] %>%
create_volcano_plot <- function(ps_obj, taxlevel, condition_col, metadata, SVs, taxonomy) {
# Convert sample data to data frame
sam_data <- as(sample_data(ps_obj), "data.frame")
# Get the top two most frequent values in the CURRENT condition column only
value_counts <- table(sam_data[[condition_col]])
top_values <- names(sort(value_counts, decreasing = TRUE))[1:2]
# Create logical vector for filtering - affects only this specific variable
keep_samples <- sam_data[[condition_col]] %in% top_values
# Prune samples but keep ALL metadata intact
ps_filtered <- prune_samples(keep_samples, ps_obj)
# Only modify the specific condition column being analyzed
sample_data(ps_filtered)[[condition_col]] <- factor(
sample_data(ps_filtered)[[condition_col]],
levels = top_values
)
# Get OTU names from filtered phyloseq object
otu_names_filtered <- rownames(otu_table(ps_filtered))
# Get taxonomy column name for specified level
tax_col <- colnames(taxonomy)[taxlevel]
# Create merged data - only filter OTUs, keep all sample info
merged_data <- data.frame(
SV = rownames(SVs),
SVs,
Taxonomy = taxonomy[, tax_col],  # Direct column access
stringsAsFactors = FALSE,
check.names = FALSE
) %>%
filter(SV %in% otu_names_filtered) %>%  # Only filter OTUs here
filter(!is.na(Taxonomy) & Taxonomy != "none" & Taxonomy != "")
# Check if data remains after filtering
if(nrow(merged_data) == 0) {
stop(paste("No taxa remaining after filtering for:", tax_col))
}
# Summarize by taxonomic level (base R for reliability)
tax_level_SVs <- aggregate(
merged_data[, -which(names(merged_data) %in% c("SV", "Taxonomy"))],
by = list(Taxonomy = merged_data$Taxonomy),
FUN = sum
)
# Prepare ALDEx2 input
rownames(tax_level_SVs) <- tax_level_SVs$Taxonomy
tax_level_SVs <- as.matrix(tax_level_SVs[, -1, drop = FALSE])
# Get conditions - ensures perfect matching
condition <- sample_data(ps_filtered)[colnames(tax_level_SVs), condition_col] %>%
as.character() %>%
as.factor()
# Run ALDEx2
aldex_data <- ALDEx2::aldex(
counts = tax_level_SVs,
conditions = condition,
mc.samples = 128,
test = "t",
effect = TRUE
)
# Create plot
results <- aldex_data %>%
rownames_to_column("Taxonomy") %>%
mutate(
Significant = we.eBH < 0.05,
Label = ifelse(Significant, paste0(Taxonomy, " (", round(we.eBH, 3), ")"), "")
)
ggplot(results, aes(x = diff.btw, y = -log10(we.eBH), color = Significant, label = Label)) +
geom_point(alpha = 0.6) +
geom_text_repel(size = 3, max.overlaps = 20) +
theme_minimal() +
labs(
title = paste("Factor:", condition_col, "- Level:", tax_col),
subtitle = paste("Comparison:", paste(top_values, collapse = " vs ")),
x = "log2(fold change)",
y = "-log10(adjusted p-value)"
) +
theme(legend.position = "none")
}
create_combined_volcano <- function(ps, factor, metadata, SVs, taxonomy) {
plots <- list()
# Try each taxonomic level with error handling
try({
plots[[1]] <- create_volcano_plot(ps, 2, factor, metadata, SVs, taxonomy)  # Phylum
})
try({
plots[[2]] <- create_volcano_plot(ps, 5, factor, metadata, SVs, taxonomy)  # Family
})
try({
plots[[3]] <- create_volcano_plot(ps, 6, factor, metadata, SVs, taxonomy)  # Genus
})
# Remove any NULL plots from failures
plots <- plots[!sapply(plots, is.null)]
if(length(plots) == 0) {
message(paste("No plots generated for factor:", factor))
return(NULL)
}
# Combine available plots
if(length(plots) >= 2) {
combined_plot <- (plots[[1]] | plots[[2]]) /
if(length(plots) > 2) plots[[3]] else patchwork::plot_spacer()
} else {
combined_plot <- plots[[1]]
}
# Add title
combined_plot <- combined_plot +
plot_annotation(
title = paste("Variable:", factor),
theme = theme(plot.title = element_text(size = 16, face = "bold")))
# Save plot
try({
ggsave(
filename = paste0(factor, "_volcano.pdf"),
plot = combined_plot,
device = "pdf",
width = 12,
height = 8
)
})
return(combined_plot)
}
# Run analysis for each factor with robust error handling
for (variable in factors) {
message(paste("\nProcessing variable:", variable))
tryCatch({
create_combined_volcano(ps, variable, metadata, SVs, taxonomy)
}, error = function(e) {
message(paste("Failed to process variable:", variable))
message(e)
})
}
metadata <- as.data.frame(sample_data(ps))  # Extract metadata
SVs <- as.data.frame(otu_table(ps))         # Extract OTU table
SVs <- data.frame(t(SVs))
taxonomy <- as.data.frame(phyloseq::tax_table(ps))    # Extract taxonomy
create_volcano_plot <- function(ps_obj, taxlevel, condition_col, metadata, SVs, taxonomy) {
# Ensure that taxonomy contains the specified level
tax_col <- colnames(taxonomy)[taxlevel]
taxonomy <- taxonomy %>%
rownames_to_column(var = "OTU_name") %>%
dplyr::select(OTU_name, !!sym(tax_col)) %>%
distinct()
# Combine SVs with taxonomy to match the specified level
SVs_with_taxonomy <- as.data.frame(SVs) %>%
rownames_to_column(var = "OTU_name")
SVs_with_taxonomy <- SVs_with_taxonomy |>
left_join(taxonomy, by = "OTU_name")
# Aggregate the SVs data to the specified taxonomic level
tax_level_SVs <- SVs_with_taxonomy %>%
dplyr::select(-OTU_name) %>%
group_by(!!sym(tax_col))
tax_level_SVs <- tax_level_SVs |>
summarise(across(everything(), ~sum(.x, na.rm = TRUE)))
tax_level_SVs <- tax_level_SVs |>
filter(!!sym(tax_col) != "none") %>%
column_to_rownames(var = tax_col)
# Convert to matrix for ALDEx2 analysis
tax_level_SVs <- as.matrix(tax_level_SVs)
condition <- as.character(as.factor(metadata[[condition_col]]))
# Run ALDEx2 analysis
aldex_data <- aldex(tax_level_SVs, conditions = condition, mc.samples = 138, test = "t", effect = TRUE)
# Combine t-test and effect size results
results <- data.frame(aldex_data)
# Merge results with taxonomy
results <- results %>%
rownames_to_column(var = tax_col)
# Create the volcano plot (before multiple testing correction)
p <- results %>%
mutate(Significant = if_else(we.ep < 0.05, TRUE, FALSE)) %>%
mutate(Taxon = as.character(!!sym(tax_col))) %>%
mutate(TaxonToPrint = if_else(we.ep < 0.05, paste(Taxon, "(", round(we.ep,3) , ")", sep = ""), "")) |>
ggplot(aes(x = diff.btw, y = -log10(we.ep), color = Significant, label = TaxonToPrint)) +
geom_text_repel(size = 4, nudge_y = 0.05, max.overlaps = Inf) +  # Increase max.overlaps
geom_point(alpha = 0.6, shape = 16) +
theme_minimal() +
xlab("log2(fold change)") +
ylab("-log10(P-value)") +
theme(legend.position = "none") +
ggtitle(paste("Factor:", condition_col,"-- Taxonomic Level:", tax_col))
return(p)
}
create_combined_volcano <- function(ps, factor, metadata, SVs, taxonomy){
volcano_plot_phylum <- create_volcano_plot(ps, 2, factor, metadata, SVs, taxonomy)
volcano_plot_family <- create_volcano_plot(ps, 5, factor, metadata, SVs, taxonomy)
volcano_plot_genus <- create_volcano_plot(ps, 6, factor, metadata, SVs, taxonomy)
combined_volcano_plot <- (volcano_plot_phylum | volcano_plot_family) / (volcano_plot_genus)
ggsave(combined_volcano_plot,
filename = paste(factor, "_volcano.pdf", sep = ""),
device = "pdf",
height = 8, width = 12, units = "in")
}
create_combined_volcano(ps, "Sex", metadata, SVs, taxonomy)

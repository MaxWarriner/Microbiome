---
title: An R Markdown document converted from "2.1.4 Figure 5. Balance-histogram. Clean.ipynb"
output: html_document
---

```{r}
packageVersion("selbal")
```

### Load libraries

```{r}
library(phyloseq)
library(selbal)
library(reshape2)
library(dplyr)
library(zCompositions)
library(ggExtra)
library(ggpubr)
library(DESeq2)
library(EnhancedVolcano)
library(rstatix)
library(pracma)
```

### Functions

```{r}
# compute the best number of taxa from cross-validation
best_nvar <- function(selbal_cv_result){
    growth_inds = which(diff(selbal_cv_result$accuracy$data$mean) > 0.001)+1
    if (length(growth_inds) > 0){
        best_ind = growth_inds[which.max(selbal_cv_result$accuracy$data$mean[growth_inds])]
        best_n = selbal_cv_result$accuracy$data$n[best_ind]
        return(best_n)
    } else {
        return(2)
    }
    
}
```

```{r}
# compute the balance value
reconstruct_balance <- function(numerator, denominator, otu){
    n = length(numerator)
    m = length(denominator)
    balance_numerator = 1/n*rowSums(log(data.frame(otu[, numerator])))
    balance_denominator = 1/m*rowSums(log(data.frame(otu[, denominator])))
    return(sqrt(n*m/(n+m))*(balance_numerator-balance_denominator))
}
```

### Load & prepare data

```{r}
# load phyloseq object
ps_genus <- readRDS('data/phyloseq/nohost_genus/phyloseq.rds')
taxa_names(ps_genus) <- tax_table(ps_genus)[, 'Genus']
ps_genus
metadata <- data.frame(sample_data(ps_genus))
```

```{r}
# based on the information of time a participant received the dworming pill the last time
# create a new column, called "prior_deworming", 
# which would contain the information about when the last deworming event tool place:
# never (within a year), > 6 months, < 6 months

# first clean the data in the 'Ifyeswhenwasthelasttimetheygaveyousuchdewormingpill' column
metadata$prior_deworming_month <- metadata[['Ifyeswhenwasthelasttimetheygaveyousuchdewormingpill']]
# remove the word month/Month
metadata$prior_deworming_month <- gsub('month', '', metadata$prior_deworming_month)
metadata$prior_deworming_month <- gsub('Month', '', metadata$prior_deworming_month)
# replace empty values with 0
metadata[metadata$prior_deworming_month == ' ', "prior_deworming_month"] <- '0'
# transform text numbers to integers
metadata$prior_deworming_month <- as.integer(metadata$prior_deworming_month)
# create a prior_deworming based on month integers
metadata$prior_deworming <- metadata$prior_deworming_month
metadata[(metadata$prior_deworming_month == 0), "prior_deworming"] <- 'never'
metadata[(metadata$prior_deworming_month > 0)&(metadata$prior_deworming_month < 7), "prior_deworming"] <- '< 6 months'
metadata[(metadata$prior_deworming_month > 6), "prior_deworming"] <- '> 6 months'
```

```{r}
# create a column, called "prior_deworming_after",
# which would contain the informaton about prior deworming event for samples at baseline
# (from "prior_deworming" column) and follow-up samples will all be marked as 'after_deworming'
metadata$prior_deworming_after <- metadata$prior_deworming
metadata[(metadata$deworming == 'after'), "prior_deworming_after"] <- 'after_deworming'

# create a column, called "prior_deworming_after",
# which to the column "prior_deworming" would add the information if sample is coming from
# the baseline or follow-up time point
metadata$prior_deworming_before_after <- paste(metadata$prior_deworming, metadata$deworming, sep='_')

# code the same information with numbers:
# 3 - never (within a year), 2 - > 6 months, 1 - < 6 months
vals <- rep(0, length(metadata$prior_deworming_after))
vals[metadata$prior_deworming_after == '< 6 months'] <- 1
vals[metadata$prior_deworming_after == '> 6 months'] <- 2
vals[metadata$prior_deworming_after == 'never'] <- 3
metadata$prior_deworming_before_after_number <- vals

# add an updated metadata to phyloseq
sample_data(ps_genus) <- metadata
```

```{r}
# transform table, to get a new one, which will contain columns with ids of samples 
# from the baseline and follow-up timepoints
# leave only samples from participants that have a follow-up sample
analysis_df <- dcast(metadata,
                     ogID+prior_deworming ~ deworming, 
                     value.var = "newID")
analysis_df <- analysis_df[!is.na(analysis_df$after), ]

row.names(analysis_df) <- analysis_df$before
row.names(analysis_df) <- analysis_df$after
head(analysis_df)
```

```{r}
# normalize genus counts
ps_normalized <- transform_sample_counts(ps_genus, function(x){x / sum(x)})

# rename taxa
taxa_names(ps_normalized) <- gsub('-', '_', taxa_names(ps_normalized))
```

```{r}
# split a phyloseq object into 2: containing samples at the baseline and follow-up timepoints
ps_before <- prune_samples(analysis_df$before, ps_normalized)
ps_after <- prune_samples(analysis_df$after, ps_normalized)
```

```{r}
# choose only taxa overlapped between baseline and follow-up time points

# select all taxa present in at least one sample of the baseline
bacteria_before <- colnames(otu_table(ps_before))
bacteria_before <- bacteria_before[colSums(otu_table(ps_before)) > 0]
length(bacteria_before)

# select all taxa present in at least one sample of the follow-up
bacteria_after <- colnames(otu_table(ps_after))
bacteria_after <- bacteria_after[colSums(otu_table(ps_after)) > 0]
length(bacteria_after)

# find an intersection between 2 taxa sets
bacteria <- intersect(bacteria_before, bacteria_after)
length(bacteria)

# select only intersected taxa in each phyloseq object
ps_before_intersected <- prune_taxa(bacteria, ps_before)
ps_after_intersected <- prune_taxa(bacteria, ps_after)
```

```{r}
# renormalize counts
ps_before_intersected <- transform_sample_counts(ps_before_intersected, function(x){x / sum(x)})
ps_after_intersected <- transform_sample_counts(ps_after_intersected, function(x){x / sum(x)})

# impute zero abundances with a Bayesian-multiplicative replacement
# for each subset (baseline and follow-up), individually, the function also removes:
#    a) taxa present in less than 50% of samples 
#    b) samples containing more than 50% absent taxa
otu_table(ps_before_intersected) <- otu_table(cmultRepl(otu_table(ps_before_intersected), 
                                                           z.warning = 0.5), taxa_are_rows=FALSE)
otu_table(ps_after_intersected) <- otu_table(cmultRepl(otu_table(ps_after_intersected),
                                                       z.warning = 0.5), taxa_are_rows=FALSE)

# ensure all taxa from baseline subset are still present in the follow-up and vice versa
bacteria_before <- colnames(otu_table(ps_before_intersected))
bacteria_after <- colnames(otu_table(ps_after_intersected))
bacteria <- intersect(bacteria_before, bacteria_after)
ps_before_intersected <- prune_taxa(bacteria, ps_before_intersected)
ps_after_intersected <- prune_taxa(bacteria, ps_after_intersected)
# renormalize
ps_before_intersected <- transform_sample_counts(ps_before_intersected, function(x){x / sum(x)})
ps_after_intersected <- transform_sample_counts(ps_after_intersected, function(x){x / sum(x)})

# ensure we still have all pairs of samples before/after
# exclude those sampples, which lost its pair during the imputation
analysis_df_ <- analysis_df
analysis_df_['before_in'] = analysis_df_$before %in% sample_names(ps_before_intersected)
analysis_df_['after_in'] = analysis_df_$after %in% sample_names(ps_after_intersected)
analysis_df_ <- analysis_df_[(analysis_df_$before_in)&(analysis_df_$after_in), ]
ps_before_intersected <- prune_samples(analysis_df_$before, ps_before_intersected)
ps_after_intersected <- prune_samples(analysis_df_$after, ps_after_intersected)

```

### Construct a microbial balance on the baseline samples, that would distinguish if samples were treated within 1 year

```{r}
# find optimal number of bacteria to balance on before deworming data
x <- data.frame(otu_table(ps_before_intersected))
y <- data.frame(sample_data(ps_before_intersected))[['prior_deworming']]
y[y != 'never'] <- TRUE
y[y == 'never'] <- FALSE
y <- factor(as.numeric(as.logical(y)))

cv.res <- selbal.cv(x, y, n.iter=5, seed=224)
cv.res$accuracy
```

```{r}
# create a balance on before deworming data
x <- data.frame(otu_table(ps_before_intersected))
y <- data.frame(sample_data(ps_before_intersected))[['prior_deworming']]
y[y != 'never'] <- TRUE
y[y == 'never'] <- FALSE
y <- factor(as.numeric(as.logical(y)))

best_nvar(cv.res)
selbal.res <- selbal(x, y, maxV=best_nvar(cv.res))
```

```{r}
selbal.res$balance.selection
```

```{r}
# compute how bacteria abundances, included in the balance score, change along the score

# select bacteria from the balance
bacteria <- c(selbal.res$numerator, selbal.res$denominator)
# log transform theitr abundances
balance_correlations <- log(x[, bacteria])
# attach the balance score to the table
balance_correlations['y'] <- selbal.res$balance.values[row.names(balance_correlations)]
# find the range of the balance score
balance_range <- seq(min(balance_correlations$y), max(balance_correlations$y), by=0.1)

# for each bacteria
bacteria_score <- lapply(bacteria, function(i){
    subtable <- data.frame(y=balance_correlations$y, 
                           bacteria=balance_correlations[[i]])
    subtable <- subtable[subtable$bacteria != 0, ]
    # interpolate bacteria log values across the balance score
    values <- interp1(subtable$y, 
                      subtable$bacteria, 
                      balance_range,
                      'linear')
    # compute the log2fold compared to the mean log abundance of the bacteria
    values <- values - mean(values)
    # approximate the change of the log bacteria abundance across the balance score with a polynomial of degree 3
    values <- as.vector(lm(values ~ poly(balance_range, 3))$fitted.values)
    # save as a data frame
    df <- data.frame(bacteria=values)
    colnames(df) <- i
    return(df)
})
# bind the results from all the bacteria of interest
bacteria_score <- do.call("cbind", bacteria_score)
bacteria_score$balance_range <- balance_range
bacteria_score <- melt(bacteria_score, id.vars=c('balance_range'))
bacteria_score$ratio <- 'denominator'
bacteria_score[bacteria_score$variable %in% selbal.res$numerator, 'ratio'] <- 'numerator'
bacteria_score$coef <- bacteria_score$variable
```

```{r}
# create a table with taxa names of genera included in the balance
labels <- data.frame(bacteria=c(selbal.res$numerator, selbal.res$denominator), 
                     x=c(1:7), 
                     y=c(rep(3, length(selbal.res$numerator)),
                         rep(-5.5, length(selbal.res$denominator))),
                     hjust=c(rep(1, length(selbal.res$numerator)),
                             rep(0, length(selbal.res$denominator))))
labels
```

```{r}
# plot the change of microbial abundance across the score
width = 4
height = 10
options(repr.plot.width=width, repr.plot.height=height)
p_bacteria <- ggplot(data = bacteria_score) + 
# plot the heatmap
    geom_tile(data = bacteria_score, aes(x=variable, y=balance_range, fill = value)) +
# plot the taxa names
    geom_text(data = labels, aes(x=x, y=y, label=bacteria, hjust=hjust), 
              vjust=0.5, angle=90, size=8, color="#535353") +
# change the color pallette
    scale_fill_gradient2(
                low="#878787", mid="white", high="#91685c", 
                 midpoint=0)  +
# rename the x ticks
  scale_x_discrete(labels = c(rep('N', length(selbal.res$numerator)),
                              rep('D', length(selbal.res$denominator)))) +
# set the y limits
  ylim(-6, 4)+
# rename x axis
  xlab('')+
# set the title of y axis
  labs(y = "Prediction Score") +
# custom styling options
    theme_light() +
     theme(axis.text=element_text(size=15),
            axis.title=element_text(size=25, face="bold"), 
            plot.title=element_text(size=25, face="bold"),
            plot.subtitle=element_text(size=22, face="plain"),
            strip.text = element_text(size = 25, hjust=0, color='#656565'), 
            axis.text.x.bottom = element_text(size=20, angle=0, face='plain', hjust=0.5),
            axis.title.y = element_text(color='#656565', face='plain'),
            axis.ticks.x=element_line(color = "darkgrey", linewidth = 0.5),
            axis.ticks.length.x.bottom=unit(0.5, "lines"),
            text = element_text(size = 25, face="bold"), 
            axis.line.y = element_line(color = "darkgrey", linewidth = 0.5), 
            axis.line.x.bottom = element_line(color = "darkgrey", linewidth = 0.5), 
            panel.border = element_rect(fill = NA, colour = "grey70", linewidth = rel(1)),
            panel.spacing.x = unit(2, "lines"),
            legend.position="bottom", 
            plot.margin = unit(c(0, 0,0, 0), "lines"))
p_bacteria

k <- 0.3
ggsave(file=file.path('figures', 'figure5', 'balance.bacteria_log2fold.svg'), plot=p_bacteria, 
       width=width*k, height=height*k, scaling = k)
```

```{r}
color = data.frame(sample_data(ps_before_intersected))[['prior_deworming_month']]
color[color == 0] = 13
levels(y) <- c('Never_before', 'Treated_before')
data_plot <- data.frame(balance = selbal.res$balance.values, y=y, color=color)
```

```{r}
# plot the balance values between 2 groups
width = 4
height = 10
options(repr.plot.width=width, repr.plot.height=height)

comparisons_paired <- list(c("Never_before", "Treated_before"))

p_balance_train <- ggplot(data_plot, aes(group=y, x=y, y=balance, color=y, fill=y)) + 
  stat_boxplot(geom = "errorbar", width = 0.1, lwd=1.3) +
  geom_boxplot(alpha=0.2, lwd=1.3, width=0.5)+
  geom_jitter(size=4, width=0.1, shape=21, color='black')+ 
  scale_fill_manual(values = c('#b9bcb5', '#878787')) +
  scale_colour_manual(values = c('#b9bcb5', '#878787'))+
  stat_compare_means(label.y=3.1, method = "wilcox.test",  paired=FALSE, 
                         label = "p.signif", 
                        comparisons = comparisons_paired, 
                        size = 7)  +
  theme_minimal() +
  ylim(-6, 4)+
  theme(axis.text=element_text(size=15),
            axis.title=element_text(size=25, face="bold"), 
            plot.title=element_text(size=25, face="bold"),
            plot.subtitle=element_text(size=22, face="plain"),
            strip.text = element_text(size = 25, hjust=0, color='#656565'), 
            axis.text.x.bottom = element_text(size=20, angle=0, face='plain', hjust=0.5),
            axis.text.x = element_blank(),
            axis.title.y = element_text(color='#656565', face='plain'),
            axis.ticks.x=element_line(color = "darkgrey", linewidth = 0.5),
            axis.ticks.length.x.bottom=unit(0.5, "lines"),
            text = element_text(size = 25, face="bold"), 
            axis.line.y = element_line(color = "darkgrey", linewidth = 0.5), 
            axis.line.x.bottom = element_line(color = "darkgrey", linewidth = 0.5), 
            panel.border = element_rect(fill = NA, colour = "grey70", linewidth = rel(1)),
            panel.spacing.x = unit(2, "lines"),
            legend.position="none", 
            plot.margin = unit(c(1,0,1,0), "lines"))  +
    labs(title = "Microbial balance differentiates treatment groups") + xlab("") + ylab("Prediction Score") 
p_balance_train
```

```{r}
# compbine 2 figures together
width = 7
height = 10
options(repr.plot.width=width, repr.plot.height=height)
p <- ggarrange(p_balance_train, p_bacteria,
          ncol = 2, nrow = 1, align = "hv", 
          common.legend = FALSE, legend = "bottom") 
print(p)

k <- 0.3
ggsave(file=file.path('figures', 'figure5', 'balance.training.svg'), plot=p, 
       width=width*k, height=height*k, scaling = k)
```

### Predict the balance score on the follow-up data

```{r}
# predict on post treatment data
numerator_bacteria <- selbal.res$numerator
denomenator_bacteria <- selbal.res$denominator
x_nonzero <- data.frame(otu_table(ps_after_intersected))
test_balance <- reconstruct_balance(numerator_bacteria, denomenator_bacteria, x_nonzero)
```

```{r}
# construct a table with the predicted balance from the follow-up samples and 
# balance score computed on the baseline samples
color = data.frame(sample_data(ps_after_intersected))[['prior_deworming_month']]
color[color == 0] = 13

y <- data.frame(sample_data(ps_after_intersected))[['prior_deworming']]
y[y != 'never'] <- TRUE
y[y == 'never'] <- FALSE
y <- factor(as.numeric(as.logical(y)))
levels(y)
levels(y) <- c('Never_after', 'Treated_after')

data_plot_predicted <- data.frame(balance = test_balance, 
                                  y=y, color=color)
data_plot_predicted <- rbind(data_plot, data_plot_predicted)
data_plot_predicted$y <- factor(data_plot_predicted$y, 
                                levels=c('Never_before','Never_after',
                                         'Treated_before','Treated_after'))

analysis_df_ <- analysis_df[!is.na(analysis_df$after), ]
row.names(analysis_df_) <- analysis_df_$after
vals_after <- analysis_df_[row.names(data_plot_predicted), 'ogID']
vals_after <- as.matrix(data.frame(x=vals_after, row.names = row.names(data_plot_predicted)))
vals_after <- data.frame(x=vals_after[!is.na(vals_after[, 'x']), ])
row.names(analysis_df) <- analysis_df$before
vals_before <-analysis_df[row.names(data_plot_predicted), 'ogID']
names(vals_before) <- row.names(data_plot_predicted)
vals_before <- as.matrix(data.frame(x=vals_before, row.names = row.names(data_plot_predicted)))
vals_before <- data.frame(x=vals_before[!is.na(vals_before[,'x']), ])
vals <- rbind(vals_before, vals_after)
data_plot_predicted$ogID <- vals[row.names(data_plot_predicted), 'x']

```

```{r}
comparisons_paired <- list(
                    c("Never_before", "Never_after"),
                    c("Treated_before", "Treated_after"))
```

```{r}
# define the style of lines connecting baseline/follow-up pairs of samples
data_plot_predicted$timepoint <- unlist(lapply(as.character(data_plot_predicted$y), 
                                        function(x){strsplit(x, split='_')[[1]][2]} ))
line_type <- dcast(data_plot_predicted, ogID~timepoint, value.var = "balance", id.vars="ogID")
line_type$line_type <- 'increase'
line_type[line_type$before > line_type$after, 'line_type'] <- 'decrease'
row.names(line_type) <- line_type$ogID
data_plot_predicted$line_type <- line_type[data_plot_predicted$ogID, 'line_type']
```

```{r}
# plot all the computed balances
width = 7
height = 9
options(repr.plot.width=width, repr.plot.height=height)

p_balance <- ggplot(data_plot_predicted, aes(group=y, x=y, y=balance, color=y, fill=y)) + 
  stat_boxplot(geom = "errorbar", width = 0.1, lwd=1.3) +
  geom_boxplot(alpha=0.2, lwd=1.3, width=0.5)+
  geom_jitter(size=4, width=0.1, shape=21, color='black')+ 
  scale_fill_manual(values = c('#b9bcb5', '#b9a04f', '#878787',  '#b9a04f')) +
  scale_colour_manual(values = c('#b9bcb5', '#b9a04f', '#878787', '#b9a04f')) +
  scale_linetype_manual(values = c('dashed', 'solid')) +
  geom_line(aes(x = y, y=balance, group = ogID, linetype=line_type),
                color = "gray", size = 0.4,) +
  stat_compare_means(label.y=3.05, method = "wilcox.test",  paired=TRUE, 
                         label = "p.signif", 
                        comparisons = comparisons_paired, 
                        size = 7) +
  theme_minimal() +
  ylim(-6, 4)+
  theme(axis.text=element_text(size=15),
            axis.title=element_text(size=25, face="bold"), 
            plot.title=element_text(size=25, face="bold"),
            plot.subtitle=element_text(size=22, face="plain"),
            strip.text = element_text(size = 25, hjust=0, color='#656565'), 
            axis.text.x.bottom = element_text(size=20, angle=0, face='plain', hjust=0.5),
            axis.text.x = element_blank(),
            axis.title.y = element_text(color='#656565', face='plain'),
            axis.ticks.x=element_line(color = "darkgrey", linewidth = 0.5),
            axis.ticks.length.x.bottom=unit(0.5, "lines"),
            text = element_text(size = 25, face="bold"), 
            axis.line.y = element_line(color = "darkgrey", linewidth = 0.5), 
            axis.line.x.bottom = element_line(color = "darkgrey", linewidth = 0.5), 
            panel.border = element_rect(fill = NA, colour = "grey70", linewidth = rel(1)),
            panel.spacing.x = unit(2, "lines"),
            legend.position="none", 
            plot.margin = unit(c(1,0,1,1), "lines"))  +
    labs(title = "Prediction score increases after the treatment") + xlab("") + ylab("Prediction Score") 
p_balance

k <- 0.3
ggsave(file=file.path('figures', 'figure5', 'balance.prediction.svg'), plot=p_balance, 
       width=width*k, height=height*k, scaling = k)
```

